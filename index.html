<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced Mapping Tool - Report QLab</title>
<style>
    body { 
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        margin: 0; padding: 10px; background: #1e1e1e; color: #d4d4d4;
        -webkit-text-size-adjust: 100%; /* Previene lo zoom del testo su iPhone */
    }
    .main-container {
        max-width: 900px; margin: 0 auto;
    }
    .panel {
        background: #252526; padding: 15px; border-radius: 8px;
        border: 1px solid #333;
    }
    h2 { 
        text-align: center; margin-top: 0; color: #00aaff;
    }
    label { 
        display: block; margin-bottom: 3px; font-size: 13px; color: #aaa;
    }
    input { 
        padding: 10px; margin-bottom: 10px; width: calc(100% - 22px);
        background: #3c3c3c; border: 1px solid #555; color: #d4d4d4; border-radius: 4px;
        font-size: 16px; /* Previene lo zoom su focus in iOS */
    }
    button, .button-label { 
        padding: 12px 15px; background: #007acc; border: none; color: #fff; 
        cursor: pointer; border-radius: 4px; transition: background-color 0.2s;
        display: inline-block; text-align: center; font-size: 16px;
    }
    button:hover, .button-label:hover { background: #005f9e; }
    canvas { 
        display: block; margin-top: 15px; background: #000; border: 1px solid #555;
        border-radius: 4px; width: 100%; height: auto; cursor: pointer;
        touch-action: none; /* Previene lo scroll durante il drag su mobile */
    }
    canvas.dragging {
        cursor: grabbing;
    }
    fieldset { 
        margin-top: 15px; border: 1px solid #444; padding: 15px; border-radius: 6px;
    }
    legend { color: #00aaff; font-weight: bold; }
    
    /* Stili per i Tab */
    .tabs-container {
        display: flex; flex-wrap: wrap; align-items: center; margin-bottom: 15px;
        border-bottom: 1px solid #444; padding-bottom: 10px;
    }
    .tab {
        padding: 8px 12px; background: #3c3c3c; border: 1px solid #555;
        cursor: pointer; border-radius: 4px; margin-right: 5px;
        display: flex; align-items: center; gap: 8px;
    }
    .tab.active { background: #007acc; color: white; }
    .delete-tab-btn {
        background: none; border: none; color: #aaa; font-weight: bold;
        padding: 0 5px; cursor: pointer; font-size: 16px;
    }
    .tab.active .delete-tab-btn { color: white; }
    .delete-tab-btn:hover { color: #ef4444; }
    
    .sub-tabs-container {
        display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;
    }

    .input-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    
    .slice-list { max-height: 200px; overflow-y: auto; padding: 5px; background: #1e1e1e; border-radius: 4px;}
    .slice-item { 
        background: #3c3c3c; padding: 10px; border-radius: 4px; 
        margin-bottom: 8px; cursor: pointer; border: 2px solid transparent;
        display: flex; justify-content: space-between; align-items: center;
    }
    .slice-item.active {
        border-color: #00aaff;
    }
    .delete-slice-btn {
        background: none; border: none; color: #aaa; font-size: 16px;
        cursor: pointer; padding: 5px;
    }
    .delete-slice-btn:hover {
        color: #ef4444;
    }

    /* Stili per il Report */
    #report-view {
        font-size: 14px;
    }
    table { 
        margin-top: 20px; 
        border-collapse: collapse; 
        width: 100%; 
    }
    table, th, td { 
        border: 1px solid #444; 
    }
    th, td { 
        padding: 8px; 
        text-align: center; 
    }
    th {
        background: #333;
    }
    .hidden {
        display: none;
    }
    #canvas-info {
        text-align: center;
        color: #aaa;
        font-size: 12px;
        margin-top: 5px;
        height: 15px;
    }
</style>
</head>
<body>

<div class="main-container">
    <div class="panel">
        <h2>Mappatura Schermi</h2>

        <fieldset>
            <legend>Progetto</legend>
            <div>
                <label for="project-name-input">Nome Progetto</label>
                <input type="text" id="project-name-input">
            </div>
            <button id="save-btn">💾 Salva</button>
            <label for="load-project-input" class="button-label">📂 Carica</label>
            <input type="file" id="load-project-input" accept=".json" style="display: none;">
        </fieldset>
        
        <div class="tabs-container" style="margin-top: 20px;">
            <div id="screen-tabs"></div>
            <button id="add-screen-btn">➕ Schermo</button>
        </div>

        <div class="sub-tabs-container">
            <button class="tab active" data-view="input">Input</button>
            <button class="tab" data-view="output">Output</button>
            <button class="tab" data-view="report">Report</button>
        </div>

        <div id="mapping-area">
            <div id="screen-controls" class="input-grid"></div>
            <h3 style="margin-top: 20px; text-align: left; font-size: 1rem;">Slices per questo schermo:</h3>
            <div id="slice-list"></div>
            <button id="add-slice-btn" style="width: 100%; margin-top: 10px;">➕ Aggiungi Slice</button>
            <fieldset id="slice-controls" class="hidden">
                <!-- Contenuto generato da JavaScript -->
            </fieldset>
            <canvas id="canvas" width="1920" height="1080"></canvas>
            <div id="canvas-info"></div>
        </div>

        <div id="report-view" class="hidden">
            <!-- Il contenuto del report verrà iniettato qui -->
        </div>
    </div>
</div>

<script>
// --- STATE MANAGEMENT ---
let project = {
    name: 'Nuovo Progetto',
    screens: []
};
let activeScreenId = null;
let activeSliceId = null;
let currentSubView = 'input';

// Variabili per il drag & drop e snap
let isDragging = false;
let dragOffsetX, dragOffsetY;
let snapLines = [];
const snapThreshold = 10; // Tolleranza per lo snap in pixel del mondo

const sliceColors = [
    "rgba(59, 130, 246, 0.7)", "rgba(16, 185, 129, 0.7)", "rgba(249, 115, 22, 0.7)",
    "rgba(236, 72, 153, 0.7)", "rgba(139, 92, 246, 0.7)", "rgba(220, 38, 38, 0.7)",
    "rgba(245, 158, 11, 0.7)"
];

// --- SALVA/CARICA ---
function updateProjectName(newName) { project.name = newName; }
function salvaProgetto() {
    if (project.screens.length === 0) { alert("Nessun progetto da salvare."); return; }
    const dataStr = JSON.stringify(project, null, 2);
    const blob = new Blob([dataStr], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const fileName = project.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    a.href = url;
    a.download = `${fileName || 'progetto'}.json`;
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
}
function caricaProgetto(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            project = JSON.parse(e.target.result);
            document.getElementById('project-name-input').value = project.name || 'Nuovo Progetto';
            const firstScreenId = project.screens.length > 0 ? project.screens[0].id : null;
            changeScreen(firstScreenId);
        } catch (error) {
            alert("Impossibile caricare il file.");
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

// --- CORE LOGIC ---
function addScreen() {
    const id = Date.now();
    project.screens.push({
        id, name: `Schermo ${project.screens.length + 1}`,
        width: 1920, height: 1080, slices: []
    });
    changeScreen(id);
}
function changeScreen(id) {
    activeScreenId = id;
    activeSliceId = null;
    switchSubView('input');
}
function switchSubView(view) {
    currentSubView = view;
    renderUI();
}
function addSlice() {
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    if (!activeScreen) return;
    const id = Date.now();
    activeScreen.slices.push({
        id, name: `Slice ${activeScreen.slices.length + 1}`,
        inputRect: { x: 0, y: 0, w: 200, h: 150 },
        outputRect: { x: 0, y: 0, w: 200, h: 150 }
    });
    selectSlice(id);
}
function selectSlice(sliceId) {
    activeSliceId = sliceId;
    renderUI();
}
function rimuoviSchermo(screenId) {
    project.screens = project.screens.filter(s => s.id !== screenId);
    if (activeScreenId === screenId) {
        const newActiveId = project.screens.length > 0 ? project.screens[0].id : null;
        changeScreen(newActiveId);
    } else {
        renderUI();
    }
}
function rimuoviSlice(sliceId) {
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    if (!activeScreen || !sliceId) return;
    activeScreen.slices = activeScreen.slices.filter(s => s.id !== sliceId);
    if (activeSliceId === sliceId) {
        activeSliceId = null;
    }
    renderUI();
}

// --- UI RENDERING ---
function renderUI() {
    const isReportView = currentSubView === 'report';
    document.getElementById('mapping-area').classList.toggle('hidden', isReportView);
    document.getElementById('report-view').classList.toggle('hidden', !isReportView);

    renderSubTabs();
    renderScreenTabs();
    
    if (isReportView) {
        generateReport();
    } else {
        const activeScreen = project.screens.find(s => s.id === activeScreenId);
        if (!activeScreen) {
            document.getElementById('mapping-area').classList.add('hidden');
            return;
        }
        renderScreenControls(activeScreen);
        renderSliceList(activeScreen);
        renderSliceControls();
        drawCanvas();
    }
}
function renderScreenTabs() {
    const tabsContainer = document.getElementById('screen-tabs');
    tabsContainer.innerHTML = '';
    project.screens.forEach(screen => {
        const tab = document.createElement('div');
        tab.className = 'tab' + (screen.id === activeScreenId ? ' active' : '');
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = screen.name;
        
        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '&times;';
        deleteBtn.className = 'delete-tab-btn';
        
        tab.appendChild(nameSpan);
        tab.appendChild(deleteBtn);
        tabsContainer.appendChild(tab);

        // Aggiungo event listener qui per robustezza
        nameSpan.addEventListener('click', () => changeScreen(screen.id));
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            rimuoviSchermo(screen.id);
        });
    });
}
function renderSubTabs() {
    document.querySelectorAll('.sub-tabs-container .tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === currentSubView);
    });
}
function renderScreenControls(screen) {
    const container = document.getElementById('screen-controls');
    container.innerHTML = `
        <div><label>Larghezza Schermo</label><input type="number" id="screen-w" value="${screen.width}"></div>
        <div><label>Altezza Schermo</label><input type="number" id="screen-h" value="${screen.height}"></div>
    `;
    document.getElementById('screen-w').addEventListener('input', (e) => updateScreenProp('width', e.target.value));
    document.getElementById('screen-h').addEventListener('input', (e) => updateScreenProp('height', e.target.value));
}
function renderSliceList(screen) {
    const list = document.getElementById('slice-list');
    list.innerHTML = '';
    screen.slices.forEach(slice => {
        const item = document.createElement('div');
        item.className = 'slice-item' + (slice.id === activeSliceId ? ' active' : '');
        
        const nameSpan = document.createElement('span');
        nameSpan.textContent = slice.name;
        nameSpan.style.flexGrow = '1';

        const deleteBtn = document.createElement('button');
        deleteBtn.innerHTML = '🗑️';
        deleteBtn.className = 'delete-slice-btn';
        
        item.appendChild(nameSpan);
        item.appendChild(deleteBtn);
        list.appendChild(item);

        item.addEventListener('click', () => selectSlice(slice.id));
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            rimuoviSlice(slice.id);
        });
    });
}
function renderSliceControls() {
    const controls = document.getElementById('slice-controls');
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    const activeSlice = activeScreen?.slices.find(s => s.id === activeSliceId);
    if (!activeSlice) { controls.classList.add('hidden'); return; }
    
    controls.classList.remove('hidden');
    const rectToEdit = (currentSubView === 'input') ? activeSlice.inputRect : activeSlice.outputRect;
    
    let buttonHTML = '';
    if (currentSubView === 'input') {
        buttonHTML = `<div style="margin-top: 15px;"><button id="copy-btn" style="padding: 5px 10px; font-size: 12px;">📋 Copia da Output</button></div>`;
    } else {
        buttonHTML = `<div style="margin-top: 15px;"><button id="copy-btn" style="padding: 5px 10px; font-size: 12px;">📋 Copia da Input</button></div>`;
    }

    controls.innerHTML = `
        <legend>Modifica Slice</legend>
        <div>
            <label>Nome Slice</label>
            <input type="text" id="slice-name" value="${activeSlice.name}">
        </div>
        ${buttonHTML}
        <div class="input-grid" style="margin-top: 10px;">
            <div><label>X</label><input type="number" id="slice-x" value="${Math.round(rectToEdit.x)}"></div>
            <div><label>Y</label><input type="number" id="slice-y" value="${Math.round(rectToEdit.y)}"></div>
            <div><label>W</label><input type="number" id="slice-w" value="${Math.round(rectToEdit.w)}"></div>
            <div><label>H</label><input type="number" id="slice-h" value="${Math.round(rectToEdit.h)}"></div>
        </div>
    `;
    
    document.getElementById('slice-name').addEventListener('input', (e) => updateSliceName(e.target.value));
    document.getElementById('copy-btn').addEventListener('click', copySliceRect);
    document.getElementById('slice-x').addEventListener('input', (e) => updateSliceProp('x', e.target.value));
    document.getElementById('slice-y').addEventListener('input', (e) => updateSliceProp('y', e.target.value));
    document.getElementById('slice-w').addEventListener('input', (e) => updateSliceProp('w', e.target.value));
    document.getElementById('slice-h').addEventListener('input', (e) => updateSliceProp('h', e.target.value));
}


// --- DATA UPDATING ---
function updateScreenProp(prop, value) {
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    if (activeScreen) {
        activeScreen[prop] = parseInt(value) || 0;
        drawCanvas();
    }
}
function updateSliceProp(prop, value) {
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    const activeSlice = activeScreen?.slices.find(s => s.id === activeSliceId);
    if (activeSlice) {
        const rectToEdit = (currentSubView === 'input') ? activeSlice.inputRect : activeSlice.outputRect;
        rectToEdit[prop] = parseInt(value) || 0;
        drawCanvas();
    }
}

function updateSliceName(newName) {
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    const activeSlice = activeScreen?.slices.find(s => s.id === activeSliceId);
    if (activeSlice) {
        activeSlice.name = newName;
        renderSliceList(activeScreen);
        drawCanvas();
    }
}

function copySliceRect() {
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    const activeSlice = activeScreen?.slices.find(s => s.id === activeSliceId);
    if (!activeSlice) return;

    let sourceRect, destRect;

    if (currentSubView === 'input') {
        sourceRect = activeSlice.outputRect;
        destRect = activeSlice.inputRect;
    } else {
        sourceRect = activeSlice.inputRect;
        destRect = activeSlice.outputRect;
    }

    destRect.x = sourceRect.x;
    destRect.y = sourceRect.y;
    destRect.w = sourceRect.w;
    destRect.h = sourceRect.h;

    renderSliceControls();
    drawCanvas();
}

// --- CANVAS & DRAWING ---
function drawCanvas() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    if (!activeScreen) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        document.getElementById('canvas-info').textContent = 'Nessuno schermo selezionato.';
        return;
    }

    const world = activeScreen;

    canvas.width = 1920;
    canvas.height = 1080;

    const scale = Math.min(canvas.width / world.width, canvas.height / world.height);
    const worldW = world.width * scale;
    const worldH = world.height * scale;
    const offsetX = (canvas.width - worldW) / 2;
    const offsetY = (canvas.height - worldH) / 2;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    ctx.strokeRect(offsetX, offsetY, worldW, worldH);
    
    document.getElementById('canvas-info').textContent = `Visualizzazione Spazio: ${world.width}x${world.height}`;

    activeScreen.slices.forEach((slice, i) => {
        const isInputView = currentSubView === 'input';
        const rect = isInputView ? slice.inputRect : slice.outputRect;
        const isActive = slice.id === activeSliceId;
        
        const drawX = offsetX + rect.x * scale;
        const drawY = offsetY + rect.y * scale;
        const drawW = rect.w * scale;
        const drawH = rect.h * scale;

        ctx.fillStyle = sliceColors[i % sliceColors.length];
        ctx.fillRect(drawX, drawY, drawW, drawH);

        ctx.strokeStyle = isInputView ? "#00aaff" : "#10b981";
        ctx.lineWidth = isActive ? 4 : 2;
        ctx.strokeRect(drawX, drawY, drawW, drawH);

        if (isActive) {
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.font = "bold 24px sans-serif";
            ctx.fillText(slice.name, drawX + 5, drawY + 25);
        }
    });

    // Disegna le linee di snap
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 1;
    snapLines.forEach(line => {
        ctx.beginPath();
        ctx.moveTo(offsetX + line.x1 * scale, offsetY + line.y1 * scale);
        ctx.lineTo(offsetX + line.x2 * scale, offsetY + line.y2 * scale);
        ctx.stroke();
    });
}

function getMousePos(canvas, evt) {
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.clientX || evt.touches[0].clientX;
    const clientY = evt.clientY || evt.touches[0].clientY;
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
    };
}

function handleMouseDown(event) {
    const mousePos = getMousePos(canvas, event);
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    if (!activeScreen) return;

    const world = activeScreen;
    const scale = Math.min(canvas.width / world.width, canvas.height / world.height);
    const offsetX = (canvas.width - world.width * scale) / 2;
    const offsetY = (canvas.height - world.height * scale) / 2;

    const slicesReversed = [...activeScreen.slices].reverse();
    for (const slice of slicesReversed) {
        const isInputView = currentSubView === 'input';
        const rect = isInputView ? slice.inputRect : slice.outputRect;
        const drawX = offsetX + rect.x * scale;
        const drawY = offsetY + rect.y * scale;
        const drawW = rect.w * scale;
        const drawH = rect.h * scale;

        if (mousePos.x >= drawX && mousePos.x <= drawX + drawW && mousePos.y >= drawY && mousePos.y <= drawY + drawH) {
            isDragging = true;
            selectSlice(slice.id);
            const worldMouseX = (mousePos.x - offsetX) / scale;
            const worldMouseY = (mousePos.y - offsetY) / scale;
            dragOffsetX = worldMouseX - rect.x;
            dragOffsetY = worldMouseY - rect.y;
            canvas.classList.add('dragging');
            return;
        }
    }
}

function handleMouseMove(event) {
    if (!isDragging || !activeSliceId) return;
    event.preventDefault();
    const mousePos = getMousePos(canvas, event);
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    const activeSlice = activeScreen?.slices.find(s => s.id === activeSliceId);
    if (!activeSlice) return;

    const world = activeScreen;
    const scale = Math.min(canvas.width / world.width, canvas.height / world.height);
    const offsetX = (canvas.width - world.width * scale) / 2;
    const offsetY = (canvas.height - world.height * scale) / 2;
    
    let newX = ((mousePos.x - offsetX) / scale) - dragOffsetX;
    let newY = ((mousePos.y - offsetY) / scale) - dragOffsetY;

    snapLines = [];
    const isInputView = currentSubView === 'input';
    const rectToEdit = isInputView ? activeSlice.inputRect : activeSlice.outputRect;
    const movingEdges = {
        left: newX, right: newX + rectToEdit.w, top: newY, bottom: newY + rectToEdit.h,
        centerX: newX + rectToEdit.w / 2, centerY: newY + rectToEdit.h / 2
    };

    const snapTargets = [
        { x: 0 }, { x: world.width / 2 }, { x: world.width },
        { y: 0 }, { y: world.height / 2 }, { y: world.height }
    ];

    activeScreen.slices.forEach(s => {
        if (s.id === activeSliceId) return;
        const r = isInputView ? s.inputRect : s.outputRect;
        snapTargets.push({ x: r.x }, { x: r.x + r.w }, { x: r.x + r.w / 2 });
        snapTargets.push({ y: r.y }, { y: r.y + r.h }, { y: r.y + r.h / 2 });
    });

    for (const target of snapTargets) {
        if (target.x !== undefined) {
            if (Math.abs(movingEdges.left - target.x) < snapThreshold) { newX = target.x; snapLines.push({ x1: target.x, y1: 0, x2: target.x, y2: world.height }); break; }
            if (Math.abs(movingEdges.right - target.x) < snapThreshold) { newX = target.x - rectToEdit.w; snapLines.push({ x1: target.x, y1: 0, x2: target.x, y2: world.height }); break; }
            if (Math.abs(movingEdges.centerX - target.x) < snapThreshold) { newX = target.x - rectToEdit.w / 2; snapLines.push({ x1: target.x, y1: 0, x2: target.x, y2: world.height }); break; }
        }
    }
    for (const target of snapTargets) {
        if (target.y !== undefined) {
            if (Math.abs(movingEdges.top - target.y) < snapThreshold) { newY = target.y; snapLines.push({ x1: 0, y1: target.y, x2: world.width, y2: target.y }); break; }
            if (Math.abs(movingEdges.bottom - target.y) < snapThreshold) { newY = target.y - rectToEdit.h; snapLines.push({ x1: 0, y1: target.y, x2: world.width, y2: target.y }); break; }
            if (Math.abs(movingEdges.centerY - target.y) < snapThreshold) { newY = target.y - rectToEdit.h / 2; snapLines.push({ x1: 0, y1: target.y, x2: world.width, y2: target.y }); break; }
        }
    }

    updateSliceProp('x', newX);
    updateSliceProp('y', newY);
    renderSliceControls();
}

function handleMouseUp() {
    isDragging = false;
    snapLines = [];
    canvas.classList.remove('dragging');
    drawCanvas();
}


// --- REPORT GENERATION ---
function generateReport() {
    const reportContainer = document.getElementById('report-view');
    const activeScreen = project.screens.find(s => s.id === activeScreenId);
    if (!activeScreen) {
        reportContainer.innerHTML = '<p>Seleziona uno schermo per vedere il report.</p>';
        return;
    }

    let tableHTML = `<h3>Report per ${activeScreen.name}</h3>
    <table>
        <tr>
            <th>Slice</th>
            <th>Tipo Calcolo</th>
            <th>Valore X</th>
            <th>Valore Y</th>
        </tr>`;

    activeScreen.slices.forEach(slice => {
        const comp = activeScreen;

        const iRect = slice.inputRect;
        const iLayoutPosX = iRect.x - (comp.width / 2);
        const iLayoutPosY = (comp.height / 2) - (iRect.y + iRect.h);

        const oRect = slice.outputRect;
        const oCtrWarpingX = oRect.x + (oRect.w / 2) - (comp.width / 2);
        const oCtrWarpingY = (comp.height / 2) - (oRect.y + (oRect.h / 2));

        tableHTML += `
        <tr>
            <td rowspan="2">${slice.name}</td>
            <td><b>Input (Layout Pos)</b></td>
            <td>${iLayoutPosX.toFixed(2)}</td>
            <td>${iLayoutPosY.toFixed(2)}</td>
        </tr>
        <tr>
            <td><b>Output (Ctr Warping)</b></td>
            <td>${oCtrWarpingX.toFixed(2)}</td>
            <td>${oCtrWarpingY.toFixed(2)}</td>
        </tr>`;
    });

    tableHTML += '</table>';
    reportContainer.innerHTML = tableHTML;
}

// --- INITIALIZATION ---
window.onload = () => {
    const canvas = document.getElementById('canvas');
    
    // Rimuovo gli 'oninput' dall'HTML e li aggiungo qui
    document.getElementById('project-name-input').addEventListener('input', (e) => updateProjectName(e.target.value));
    document.getElementById('load-project-input').addEventListener('change', caricaProgetto);
    document.getElementById('save-btn').addEventListener('click', salvaProgetto);
    document.getElementById('add-screen-btn').addEventListener('click', addScreen);
    document.getElementById('add-slice-btn').addEventListener('click', addSlice);
    
    document.querySelectorAll('.sub-tabs-container .tab').forEach(tab => {
        tab.addEventListener('click', () => switchSubView(tab.dataset.view));
    });

    // Eventi Mouse
    canvas.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('mouseup', handleMouseUp);

    // Eventi Touch per mobile
    canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
    window.addEventListener('touchmove', handleMouseMove, { passive: false });
    window.addEventListener('touchend', handleMouseUp);

    if (project.screens.length === 0) addScreen();
    else changeScreen(project.screens[0].id);
    renderUI();
};

</script>
</body>
</html>
